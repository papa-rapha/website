---
title: "Velogames spring classics: how to optimize your riders' choices and your transfers strategy?"
author: "Rapha√´l Nedellec"
date: "2023-04-28"
categories: [cycling, R, web-scraping, optimization, fantasy-cycling]
knitr:
  opts_chunk: 
    echo: true
format:
  html:
    toc: true
    code-fold: true
    self-contained: true
---

```{r}
#| echo: false
#| results: 'hide'
long_slug <- "04-2023-Velogames-springclassics"
# NOTE: after finishing post, run renv::snapshot() and copy the renv.lock file 
# from the project root into the post directory
renv::use(lockfile = "renv.lock")
```

# Velogames Spring Classics

The [Velogames](https://www.velogames.com/) website is another site for cycling fan and fantasy games lovers. The site has been [up and running from 1997](https://www.velogames.com/about.php), and that's just simply amazing. Great job and congrats to its maintainer, George!  

The competition offer is very rich nowadays. The [Six Superclasico](https://www.velogames.com/sixes-superclasico/2023/) competiton is up all year long covering the classics, and your task is to pick the best 6 man team for every race, while the [Women classics](https://www.velogames.com/womens-classics/2023/) is similar but focused on women professional cycling. You also have races for one-week and GT races belonging in the [Stage Race Championships](https://www.velogames.com/index_stage_season_2023.php) category. I'll probably write another article about eternal regrets on those races too, but for today, let's focus on the [Velogames Spring Classics](https://www.velogames.com/spring-classics/2023/)! Note that I'm not the only geek interested in this problem. [@jeremader](https://twitter.com/jeremader) and [@CalumLonie](https://twitter.com/CalumLonie) have been posting regularly on Twitter provisional and best teams results. In fact, it is a post by [@CalumLonie](https://twitter.com/CalumLonie) last year that is behind my motivation to look deeper at this problem.

<blockquote class="twitter-tweet tw-align-center">
<p lang="nl" dir="ltr">Best possible <a href="https://twitter.com/velogames?ref_src=twsrc%5Etfw">@velogames</a> team for the entire Spring Classics:<br><br>Mathieu Van Der Poel<br>Dylan Van Baarle<br>Matej Mohoriƒç<br>Stefan K√ºng<br>Tiesj Benoot<br>Christophe Laporte<br>Dylan Teuns<br>Valentin Madouas<br>Ben Turner<br>Jan Tratnik<br>Magnus Sheffield<br>Tom Devriendt<br><br>11975 points, 100 credits</p>&mdash; Calum Lonie üáÆüá™üá®üáµüá™üá∫ (@CalumLonie) <a href="https://twitter.com/CalumLonie/status/1519054469723525124?ref_src=twsrc%5Etfw">April 26, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

The Velogames Spring Classics is a unique competition. Depending on the year, up to 12 races are scheduled in this challenge. The goal is simple, build your team of 12 riders and maximize the number of points scored on all the 12 races. It is already hard enough, but the game becomes spicy if you add one more constraint: you have a limited number of transfers! You'll have to decide when you want to make a replacement, and who to keep even if they are not on the startlist for the race of the day. Let's take a look at the best teams you could have done in 2021 and 2022.


# Collecting data

Once again, we'll use some scrapping to collect the data on the Velogames website. The velogames owner makes an amazing job at organizing the competitions and keeping the website up-to-date, and has even mentioned the possibility to expose by API the different data used in the game (). 


```{r}
#| include: false

library(tibble)
library(rvest)
library(stringr)
library(purrr)
library(dplyr)
library(tidyr)
```


```{r}
#| label: collect-vg-data
#| code-summary: Scrap results from Velogames website
#| cache: true

# function to extract values from line in 
# velogames spring classics race results page
values_from_li <- function(li) {
  li |>
    html_elements("span:nth-child(2)") |>
    html_text() |>
    str_extract("^\\d+") |> 
    as.integer() -> points
  
  li |> 
    html_element("h3 > a") |> 
    html_text() -> name
  li |> 
    html_elements("p") |> 
    html_text() -> txt
  
  tibble(team = txt[[2L]],
         name = name,
         points = points)
}

# function to collect results for every races
scrap_spring_classics_results <- function(year) {
  
  nb_races <- switch(as.character(year),
                     "2021" = 11,
                     "2022" = 12,
                     "2023" = 12,
                     stop("Must be one of 2021, 2022, 2023"))
  
  # get results for all individual races
  map(1:nb_races, function(x) {
    url <- paste0("https://www.velogames.com/spring-classics/",
                  year, "/ridescore.php?ga=13&st=", x)
    read_html(url) |> 
      html_element("#users") |> 
      html_element("ul") |> 
      html_elements("li") |> 
      map(values_from_li) |> 
      bind_rows() 
  }) -> race_results
  
  # get overall perf
  overall <- 
    paste0("https://www.velogames.com/spring-classics/",
           year, "/ridescore.php?ga=13") |> 
    read_html() |> 
    html_element("#users") |> 
    html_element("ul") |> 
    html_elements("li") |> 
    map(values_from_li) |> 
    bind_rows() 
  
  # get race names
  read_html(paste0("https://www.velogames.com/spring-classics/", year, "/ridescore.php")) |> 
    html_element("div.wrap-content") |> 
    html_elements("a") |> 
    html_text() -> race_names
  
  # bind overall and individual results
  race_results <- c(list(overall), race_results)
  
  # bind all results
  map2(race_names, race_results, function(x, y) {
    mutate(y, race = !!x)
  }) |> 
    bind_rows() |>
    select(-team) |> 
    pivot_wider(names_from = "race", values_from = points) |> 
    rename(Rider = name) -> all_results
  
  return(all_results)
}

# function to collect riders cotation
scrap_spring_classics_cost <- function(year) {
  url <- paste0("https://www.velogames.com/spring-classics/",
                year, "/riders.php")
  read_html(url) |> 
    html_element("table") |> 
    html_table() |> 
    select(Rider, Cost, Team)
}

# iterate over the years
all_results <- 
  map(2021:2022, scrap_spring_classics_results) |> 
  setNames(2021:2022)

# iterate over the years
all_costs <- 
  map(2021:2022, scrap_spring_classics_cost) |> 
  setNames(2021:2022)

# we merge the two tables together, replacing NA by 0
# we use `TOT`:`Li√®ge-Bastogne-Li√®ge` to select columns
# as Overall column is before the first race (MSR)
# and LBL the last one of the challenge every year
all_results_21_22 <- 
  map2(all_results, all_costs, \(x, y) {
    left_join(y, x, by = "Rider") |> 
      mutate(across(`Overall`:`Li√®ge-Bastogne-Li√®ge`,
                    ~replace_na(., 0)))
  }) 
```

```{r}
#| include: false
library(reactable)

# define function for table formatting
format_table <- function(data, ...) {
  reactable(data, 
            defaultColDef = colDef(width = 55),
            columns = list(
              Rider = colDef(width = 210, sticky = "left"),
              Overall = colDef(width = 70)
            ), 
            compact = TRUE, ...)
}
```


::: {.panel-tabset}

## 2021

```{r}
#| echo: false

all_results_21_22[["2021"]] |>
  rename(MSR = `Milano-Sanremo`,
         BDP = `Oxyclean Classic Brugge-De Panne`,
         E3 = `E3 Saxo Bank Classic`,
         GW = `Gent-Wevelgem`,
         DVV = `Dwars door Vlaanderen`,
         RVV = `Ronde van Vlaanderen`,
         SCH = `Scheldeprijs`,
         BP = `De Brabantse Pijl `,
         AGR = `Amstel Gold Race`,
         FW = `La Fl√®che Wallonne`,
         LBL = `Li√®ge-Bastogne-Li√®ge`) -> data_2021


data_2021 |> 
  select(-Team) |> 
  format_table()
```


## 2022

```{r}
#| echo: false
all_results_21_22[["2022"]] |>
  rename(MSR = `Milano-Sanremo`,
         BDP = `Minerva Classic Brugge-De Panne`,
         E3 = `E3 Saxo Bank Classic`,
         GW = `Gent-Wevelgem`,
         DVV = `Dwars door Vlaanderen`,
         RVV = `Ronde van Vlaanderen`,
         SCH = `Scheldeprijs`,
         BP = `Brabantse Pijl`,
         PR = `Paris-Roubaix`,
         AGR = `Amstel Gold Race`,
         FW = `La Fl√®che Wallonne`,
         LBL = `Li√®ge-Bastogne-Li√®ge`) -> data_2022


data_2022 |> 
  select(-Team) |> 
  format_table()
```

:::


# What were the best teams possible in 2021 and 2022?

## Without transfers

Similarly to the previous post about [Rivals manager best team](https://papa-rapha.github.io/website/posts/03-2023-velogames-knapsack/), it is possible to formulate this question as a linear programming problem. Let's start with a simplified problem. What would have been the best team possible without any replacement - i.e. if you had kept the same team from MSR (*Milano San remo*) to LBL (*Li√®ge-Bastogne-Li√®ge*). In that case, the problem can be formulated as follow:


Maximize the total number of points collected

$$
\max \sum_{i=1}^N x_i\cdot\mathrm{Points}_i
$$

with a team of exactly 12 riders

$$
s.t. \sum_i x_i = 12
$$
with the team cost not exceeding 100 credits.

$$
\sum_i x_i\cdot\mathrm{Cost}_i \leq 100
$$
```{r}
#| label: lp-wo-transfers
#| code-summary: Function to solve LP problem

library(lpSolve)
maximize_score_wo_transfers <- function(data) {
  # define obj function
  # this corresponds to maximizing the sum of points 
  f.obj <- data[["Overall"]]
  
  N <- nrow(data)
  # define constraints
  # 1st and 2nd constraints concern all x_i
  # 3rd constraints is for cost constraint
  # 4th is about cost constraint for top league
  f.con <- matrix(c(rep(1, N),
                    data[["Cost"]]),
                  nrow = 2, byrow = TRUE)
  
  # Inequality signs for constraints
  f.dir <- c("==", "<=")
  
  # Threshold values for constraints (rhs)
  f.rhs <- c(12, 100)
  
  # Problem definition
  linprog <- lp(direction = "max",
                f.obj,
                f.con,
                f.dir, 
                f.rhs,
                binary.vec = 1:length(f.obj))
  
  # We return as a result the dataframe's rows corresponding to
  # riders in the best team possible
  result <- data[as.logical(linprog$solution), ]
  return(result)
}
```

::: {.panel-tabset}

## 2021

```{r}
#| echo: false
select(data_2021, -Team) |> 
  maximize_score_wo_transfers() -> res_2021
res_2021 |> 
  format_table(pagination = FALSE)
```

## 2022

```{r}
#| echo: false
select(data_2022, -Team) |> 
  maximize_score_wo_transfers() -> res_2022
res_2022 |> 
  format_table(pagination = FALSE)
```
:::

In 2021, the best team without transfers would have scored `r res_2021 |> pull(Overall) |> sum()` points, and  `r res_2022 |> pull(Overall) |> sum()` points in 2022. This means this strategy would have ranked 99th in 2021 and 26th in 2022. Not bad! Note that we have the same results than [@CalumLonie](https://twitter.com/CalumLonie), it's a relief!

It seems quite obvious that with transfers, we could do much better. But, by how much?

## With transfers

### Toy problem

Before trying to solve the problem at scale, let's imagine a simpler problem with way less riders. Let's think about a problem where we would have only 4 riders, and 3 races.


```{r}
#| label: toy-problem-table
#| code-summary: Toy table
tribble(~Rider, ~Cost, ~Race_1, ~Race_2, ~Race_3,
        "A", 40, 200, 100, 0,
        "B", 50, 300, 0, 300,
        "C", 60, 0, 300, 300,
        "D", 40, 100, 150, 100) -> data_toy
data_toy |> 
  reactable(columns = list(
    Race_1 = colDef(name = "Race 1"),
    Race_2 = colDef(name = "Race 2"),
    Race_3 = colDef(name = "Race 3")
  ))
```

Our team must have exactly two riders, and we are allowed 2 transfers only. What is the best strategy to optimize score ? We can formulate our problem as follow:

$$
\max \sum_{i=1}^4\sum_{j=1}^3 x_{i,j}\cdot\mathrm{Points}_i
$$
We want to maximize the sum of points obtained (by Riders A, B, .., D during races 1, 2, 3) with the constraints:


$$
\begin{align*} 
s.t. & \sum_{i=1}^4 x_{i, 1} = 2 \\
& \sum_{i=1}^4 x_{i, 2} = 2 \\
& \sum_{i=1}^4 x_{i, 3} = 2 
\end{align*}
$$
meaning that for each race, we cannot have more than two riders in the team, and

$$
\begin{align*} 
s.t. & \sum_{i=1}^4 x_{i, 1}\cdot\mathrm{Cost}_i <= 100 \\
& \sum_{i=1}^4 x_{i, 2}\cdot\mathrm{Cost}_i <= 100  \\
& \sum_{i=1}^4 x_{i, 3}\cdot\mathrm{Cost}_i <= 100  
\end{align*}
$$
we must still respect the constaint over the cost of our team. We can add the transfer constraint. Let's explain what it means. Let's say rider A (i=1) is in the team for race one, and is not for race 2. That means that :

$$
x_{1,1} - x_{1,2} = 1 - 0 = 1
$$
On the contrary, let say that rider B (i=2) wasn't in the team for race A but entered for race 2, that means that:

$$
x_{2,1} - x_{2,2} = 0 - 1 = -1
$$
We need to limit the number of transfers to 2 in our toy problem. It could be translated by the constraint $\sum_{i,j} |x_{i,j} - x_{i,j-1}| \leq 4, \forall j\in [2,3]$. Since adding or removing a rider implies that the values goes up by one, and that adding a rider implies that we remove one necessarily (due to the size of the team having to be 12 at all time), 2 transfers means that our absolute values has to be 4. Let's illustrate this with our example. The problem is simple enough for us to identify the best team manually. For race one, we should pick riders A and B, and use our 2 transfers for race 2 by swapping riders A and B for riders C and D. Then, we should stick to riders C and D for the last race. If we take a look at the matrix representation of $\sum_{i,j} x_{i,j} - x_{i,j-1}, \forall j\in [2,3]$ :

$$
\begin{bmatrix}
-1 & 0\\
-1 & 0\\
1 & 0\\
1 & 0\\
\end{bmatrix}
$$
we see that riders making a transfer implies both that we remove a rider from the team, for example $x_{1,2} - x_{1,1} = -1$ and that we add a new rider in the team $x_{3,2} - x_{3,1} = 1$. So the question is, how can we translate that into our LP problem? We need to linearize our constraint on the absolute values first. Indeed, to incorporate this constraint into our problem, we need to instead add the two equivalent linear constraints:

$$
|X| \leq k \iff X \leq k \ \ \mathrm{and} \ \ -X \leq k
$$
In our case, to count the total number of replacements, we'll make use of a new artificial variable, $s_{i,j}$. This will allow us to count that the total number of replacement will not be above the allowed number.

Now that we have our ideas in place, let's build our linear program piece by piece. First, we need to define our objective function. Our goal is to maximize our total number of points. We have 4 riders and 3 races, so we have 12 binary variables to compute corresponding to those combinations. We have also introduced our artificial variables to count the number of replacements. The team for the first race is made without using any replacement, which only start to count at the second race if we make any change. Therefore, we need to count all the changes between $x_{i,1}, \forall i$ and $x_{i,2}, \forall i$, and $x_{i,2}, \forall i$ and $x_{i,3}, \forall i$, so $4*2 = 8$ possible replacements. 

Using `lpSolve`R library, we can define our objective function as:

```{r}
#| label: lp-w-rep-obj-func
#| code-summary: Objective function

# define obj function
# this corresponds to maximizing the sum of points
# over all stage races
# we also add some zeros for the variables corresponding to transfers
# we still have to estimate those artificial variables
# but they don't matter in the f.obj maximization
N_riders <- 4L
N_races  <- 3L
points <- c(data_toy$Race_1, data_toy$Race_2, data_toy$Race_3)
transfers <- numeric(N_riders * (N_races - 1L))
f.obj <- c(points, transfers)
```

Then, we need to take care of the constraints:

- Team must be of size 2 for all 3 races
- Cost cannot exceed 100
- We are allowed 2 transfers only

The first constraint can be written as:

```{r}
#| label: lp-w-rep-constr-size
#| code-summary: Team size constraint

# each constraint is a vector of size 20:
# the first 12 values correspond to the actual x_{i,j}
# the last 8 to the s_{i,j} corresponding to the artificial variables
# introduced for the replacements counting
con.team_size <- c(
  c(rep(1, 4), rep(0, 16)),            # team size 1st race
  c(rep(0, 4), rep(1, 4), rep(0, 12)), # team size 2nd race
  c(rep(0, 8), rep(1, 4), rep(0, 8))   # team size 3rd race
)

sign.team_size <- rep("==", 3)
values.team_size <- rep(2, 3)
```

The cost constraint is:

```{r}
#| label: lp-w-rep-constr-cost
#| code-summary: Team cost constraint

cost <- data_toy$Cost
con.team_cost <- c(
  c(cost, rep(0, 16)),                 # team cost 1st race
  c(rep(0, 4), cost, rep(0, 12)),      # team cost 2nd race
  c(rep(0, 8), cost, rep(0, 8))        # team cost 3rd race
)

sign.team_cost <- rep("<=", 3)
values.team_cost <- rep(100, 3)
```

And now, the replacements. We introduce 8 + 1 constraints: one for each possible substitution for races 2 and 3 and a final one to ensure that we do not have more than 2 replacements. For every possible replacement, we need to make sure that:

$$
\begin{align*}
x_{i,j} - x_{i,j-1} &\leq s_{i,j}, \forall i \in [1,4], \forall j \in [2,3]\\
x_{i,j-1} - x_{i,j} &\leq s_{i,j}, \forall i \in [1,4], \forall j \in [2,3]
\end{align*}
$$

We can write these constraints as:

$$
\begin{align*}
x_{i,j} - x_{i,j-1} - s_{i,j} &\leq 0, \forall i \in [1,4], \forall j \in [2,3]\\
x_{i,j-1} - x_{i,j} -s_{i,j} &\leq 0, \forall i \in [1,4], \forall j \in [2,3]
\end{align*}
$$

And therefore, write the constraints in the code as:

```{r}
#| label: lp-w-rep-constr-repl
#| code-summary: Replacements' constraints

con.repl <- c(
  c(1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0), # s_{1,2}
  c(0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0), # s_{2,2}
  c(0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0), # s_{3,2}
  c(0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0), # s_{4,2}
  c(0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0), # s_{1,3}
  c(0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0), # s_{2,3}
  c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0), # s_{3,3}
  c(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1), # s_{4,3}
  c(-1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0), # s_{1,2}
  c(0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0), # s_{2,2}
  c(0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0), # s_{3,2}
  c(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0), # s_{4,2}
  c(0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0), # s_{1,3}
  c(0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0), # s_{2,3}
  c(0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0), # s_{3,3}
  c(0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1)  # s_{4,3}
)

sign.repl <- rep("<=", 16)
values.repl <- integer(16)
```

Finally, we must make sure that we limit the total number of replacements.

```{r}
#| label: lp-w-rep-constr-repl-tot
#| code-summary: Total number of replacements
con.tot_repl <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1)
sign.tot_repl <- c("<=")
values.tot_repl <- c(4) # 2 * 2
```


```{r}
#| label: solving-the-lp
#| code-summary: Linear Program

f.obj <- f.obj
f.con <- matrix(c(con.team_size, con.team_cost, con.repl, con.tot_repl),
                byrow = TRUE,
                nrow = 23)
f.dir <- c(sign.team_size, sign.team_cost, sign.repl, sign.tot_repl)
f.rhs <- c(values.team_size, values.team_cost, values.repl, values.tot_repl)

# Problem definition
linprog <- lp(direction = "max",
              f.obj,
              f.con,
              f.dir,
              f.rhs,
              all.bin = TRUE)
linprog
```
```{r}
#| label: success-table
#| code-summary: Results' table

sol <- matrix(linprog$solution[1:12], ncol = 3)
colnames(sol) <- c("Race_1", "Race_2", "Race_3")

style_cell <- function(value, index, name) {
  s <- sol[index, name]
  if (s > 0) {
    list(backgroundColor = "#41b148")
  }
}

data_toy |> 
  reactable(columns = list(
    Race_1 = colDef(name = "Race 1", style = style_cell),
    Race_2 = colDef(name = "Race 2", style = style_cell),
    Race_3 = colDef(name = "Race 3", style = style_cell)
  ))
```

We have the solution to our small example problem! The best strategy is indeed to pick riders A and B for the first race, and then to swap them for riders C and D before race 2, using our two transfers. This strategy maximizes the rewards while being compliant with all our constaints. 


### Full problem

We can now tackle the full scale problem. We have 875 riders for the year 2021, and 929 riders for the year 2022, and respectively 11 and 12 races. The problem size is much bigger. To be more efficient, and given the sparse nature of our constraints, we'll use a sparse matrix representation to represent our constraints.


```{r}
#| label: fnc-fobj
#| code-summary: Function to compute objective function

#' @param race_matrix, matrix with n_riders rows and n_races col, each value being the perf for rider i at race j
#' @param cost, vector of length n_riders, corresponding to the cost for every rider. The cost is the same for each race in the Spring Classics competition.
comp_obj_func <- function(race_matrix, cost) {
  cost_var <- rep(cost, ncol(race_matrix))
  repl_var <- integer(nrow(race_matrix) * (ncol(race_matrix) - 1))
  c(cost_var, repl_var)
}
```

```{r}
#| label: fnc-fcon
#| code-summary: Function to compute constraints

comp_constraints <- function(race_matrix, cost) {
  c()
}
```

```{r}
#| label: solving-lps
#| code-summary: Solving LPs for 2021 and 2022


```



# Best teams and optimal strategy

## 2021

## 2022

# Conclusion


# Session Info {.appendix}

```{r}
#| label: appendix
#| echo: false
source("../../R/appendix.R")
insert_appendix(
  repo_spec = "papa-rapha/website", 
  name = long_slug
)
```

<details><summary>Toggle</summary>

```{r}
#| echo: false
library(sessioninfo)
# save the session info as an object
pkg_session <- session_info(pkgs = "attached")
# get the quarto version
quarto_version <- system("quarto --version", intern = TRUE)
# inject the quarto info
pkg_session$platform$quarto <- paste(
  system("quarto --version", intern = TRUE), 
  "@", 
  quarto::quarto_path()
)
# print it out
pkg_session
```

</details>